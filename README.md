io_uring1.1  webserver
模型：主线程负责分类任务，以及io_uring任务的提交设置，线城市负责解析完成任务！！
一，##采用io_uring异步io，减少系统调用的损耗，（两个环形缓冲区,mmap)提升速度
二，##用户态环形缓冲区设计 ringbuffer;，减少内存拷贝，移动问题。
##用户态内存池设计：采用slab方式管理连接数量，提前分配多个slab!!!，大小固定，（三个链表，分配速度快，容易管理）孩子系统分配额外缓冲区，减少空间浪费（碎片）快速分配，利用对象构造与析构，（避免重复初始化），
但是，少量连接时候空间浪费！！！！
######采用slab管理连接，slab管理器（空的 满的，部分）管理slab，（每个连接的缓冲区大小是固定的，超多这个缓冲区，从伙伴系统缓冲区拿）
######采用伙伴系统管理缓冲区设置！采用2次幂方法分配大小，采用数组的链表方式管理，（分离式链表）大小不固定！！分配和释放块，但是内部碎片高，有合并分裂开销！
伙伴系统适合分配大文件对象，
三，任务分配器和任务工厂(虚函数基类）和任务注册器；
    io_uring 虽然式异步的，但是fd连接处理式一个个同步处理，先经过任务分配分类，再交给线程池完成
四，线程池设计采用主c14方式，可以捕获任务返回值！！线程池完成任务，并需要（设置io_uring的读或者写任务）
五，任务的处理，响应过大的话采用分块发送！零拷贝技术！！
--
(未完成）
-----进阶线程换成协程设计
六，定时器的实现，使用最小堆的方式！利用时间戳解决连接超时，以及大空间缓存分配浪费问题！（定时清理）->进阶采用时间轮
七，http任务解析器（已完成)，file任务解析器，以及chat聊天功能
八，检测工具：内存泄露检测，以及死锁问题！！！！
九，存储问题：musql redis nginx的集成，以及mysql连接池 ，以及自己实现一个kv存储！
十，设计
